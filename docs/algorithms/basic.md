📘 演算法基本概念（Big-O、時間複雜度、分析方法）

演算法（Algorithm）是解決問題的一組明確步驟。
在資訊課與 APCS 中，我們不只要求能寫出正確的程式，
也要能寫出 更快、效率更高的程式。

因此我們必須學習：

時間複雜度（Time Complexity）

空間複雜度（Space Complexity）

Big-O 記號（O-notation）

如何估算程式效率

🧭 1. 什麼是 Big-O 記號？

Big-O 是用來描述「當輸入 n 變大時，程式執行時間成長的速度」。

例子：

n（資料量）	程式執行時間

10	跑 0.01 秒

1000000	跑 10 秒

→ 這種「資料變多 → 程式變慢」的比例，就用 Big-O 來描述。

🧪 2. 常見的時間複雜度（由快到慢）

Big-O	名稱	範例	說明

O(1)	常數時間	直接取 a[3]	不隨 n 變化

O(log n)	對數時間	二元搜尋	每次砍一半

O(n)	線性時間	for 迴圈 n 次	資料越大跑越久

O(n log n)	n 乘 log n	快速排序	APCS 最愛

O(n²)	平方時間	雙層迴圈	很容易超時

O(2ⁿ)	指數時間	子集合枚舉	n=30 就爆炸

O(n!)	階乘	全排列	n=12 就跑不動

🔍 3. 如何估算時間複雜度？

✔ 3-1：看「迴圈層數」

for (int i=0; i<n; i++)   // O(n)

    for (int j=0; j<n; j++) // O(n)


→ 兩層相乘 → O(n²)

✔ 3-2：看資料縮小方式
while n > 1:

    n //= 2      # 每次砍一半


→ log₂(n) 次 → O(log n)

✔ 3-3：只留最大影響項（丟掉小項）

O(n) + O(log n) = O(n)


因為 n >> log n

所以 Big-O 只保留最大的。

🧠 4. 時間複雜度範例（高中生最常見）

🌟 例 1：哪一段比較快？

for (int i = 0; i < n; i++);       // O(n)

for (int i = 0; i < n*n; i++);     // O(n²)


→ O(n) 明顯比較快

🌟 例 2：加法迴圈 vs 乘法迴圈

for (int i = 0; i < n; i++)


→ 每次 +1 → 跑 n 次 → O(n)

for (int i = 1; i < n; i *= 2)


→ 每次乘 2 → log₂(n) 次 → O(log n)

🌟 例 3：複合迴圈

for (int i=0; i<n; i++)

    for (int j=0; j<i; j++)


外層 n 次

內層平均 n/2 次

→ 約 (n²)/2 → O(n²)

🧮 5. APCS / ZeroJudge 常見時間複雜度限制

題目最大 n	建議複雜度	可行方法

n=10⁵	O(n), O(n log n)	排序、map、heap

n=10⁶	O(n)	prefix sum

n=10⁷	只能 O(1)	數學公式

圖有 10⁵ 邊	BFS / DFS	O(V+E)

n=20	O(2ⁿ) 可接受	子集合枚舉

🧩 6. 空間複雜度（簡易版）

描述程式需要多少額外記憶體。

例：

int a[100000];  // 使用約 400 KB


→ 空間複雜度 O(n)

x = 123  # 使用固定大小


→ 空間複雜度 O(1)

📚 7. 學習演算法的重點觀念

不用計算實際秒數，只比較長期成長速度

只看最大影響項（Big-O）

能不能過時間限制（Time Limit）比較重要

寫出 O(n log n) 或 O(n) 的程式才是關鍵

🏁 8. 推薦練習題（APCS / ZeroJudge）
ZeroJudge

d065：時間複雜度判斷

a225：迴圈模擬

c291：效率比較

APCS 題型

排序題（需要 O(n log n)）

走迷宮（BFS → O(V+E)）

字串處理（O(n)）

模擬題（看迴圈層數剖析）

🎉 結語

演算法不是背公式，而是學會「看程式就能估計效率」。
掌握 Big-O，你就能：

準備 APCS

加強競賽能力

寫出快又漂亮的程式

下一章建議進入：
👉 搜尋與圖論（BFS / DFS）
