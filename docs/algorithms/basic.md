# 📘 演算法基本概念（Big-O、時間複雜度、分析方法）

演算法（Algorithm）是一組明確、可重複的步驟，用來解決問題。  
在資訊課與 APCS 中，我們不只要寫出正確的程式，也要寫出**高效率**的程式。  

因此需要理解：

- 時間複雜度（Time Complexity）
- 空間複雜度（Space Complexity）
- Big-O 記號（O-notation）
- 如何估算程式效率

---

## 🧭 1. 什麼是 Big-O 記號？

Big-O 用來描述「當輸入量 n 變大時，程式執行時間的成長速度」。

範例：

| n（資料量） | 程式執行時間 |
| ----------- | ------------ |
| 10          | 0.01 秒      |
| 1,000,000   | 10 秒        |

→ **資料越多，程式越慢**，Big-O 描述的就是這個成長速度。

---

## 🧪 2. 常見的時間複雜度（由快到慢）

| Big-O | 名稱 | 範例 | 說明 |
|-------|------|------|-------|
| O(1) | 常數時間 | 取 a[3] | 不隨 n 變化 |
| O(log n) | 對數時間 | 二元搜尋 | 每次砍一半 |
| O(n) | 線性時間 | for 迴圈 n 次 | n 越大跑越久 |
| O(n log n) | n × log n | 快速排序 | APCS 最常見 |
| O(n²) | 平方時間 | 雙層迴圈 | 易超時 |
| O(2ⁿ) | 指數 | 子集合枚舉 | n=30 就爆炸 |
| O(n!) | 階乘 | 全排列 | n=12 就跑不動 |

---

## 🔍 3. 如何估算程式的時間複雜度？

### ✔ 3-1：看迴圈層數

```cpp
for (int i=0; i<n; i++)       // O(n)
    for (int j=0; j<n; j++)   // O(n)
→ 兩層相乘：O(n²)

✔ 3-2：看資料縮小方式
python
複製程式碼
while n > 1:
    n //= 2
→ 每次砍一半 → O(log n)

✔ 3-3：只留最大影響項
mathematica
複製程式碼
O(n) + O(log n) = O(n)
因為 n >> log n
所以 Big-O 只保留最大項。

🧠 4. 常見範例（高中生最常見）
🌟 例 1：哪個比較快？
cpp
複製程式碼
O(n)
O(n*n)  // 比較慢
🌟 例 2：加法 vs 乘法迴圈
cpp
複製程式碼
for (int i=0; i<n; i++)   // O(n)

for (int i=1; i<n; i*=2)  // O(log n)
🌟 例 3：複合迴圈
cpp
複製程式碼
for (int i=0; i<n; i++)
    for (int j=0; j<i; j++)
→ 內層平均 n/2 次 → 約 n²/2 → O(n²)

🧮 5. APCS / ZeroJudge 常見複雜度限制
題目 n 範圍	建議複雜度	常見解法
n = 10⁵	O(n), O(n log n)	排序、map、heap
n = 10⁶	O(n)	prefix sum
n = 10⁷	O(1)	數學公式
圖邊數 = 10⁵	BFS/DFS = O(V+E)	走迷宮、連通元件
n = 20	O(2ⁿ) 可接受	子集合枚舉

🧩 6. 空間複雜度（簡易版）
O(n)：需要隨 n 變大的記憶體

cpp
複製程式碼
int a[100000];  // 約 400 KB
O(1)：固定記憶體

python
複製程式碼
x = 123
📚 7. 學習演算法的重要觀念
比的是「長期成長速度」，不是實際秒數

Big-O 只看最大項

APCS 最常考 O(n)、O(n log n)、O(n²)

如何避免 TLE（Time Limit Exceeded）是重點

看程式就能快速估計效率是關鍵能力

🏁 8. 推薦練習題（APCS / ZeroJudge）
✔ ZeroJudge
d065：時間複雜度判斷

a225：迴圈模擬

c291：效率比較

✔ APCS 題型
排序（需要 O(n log n)）

走迷宮（BFS → O(V+E)）

字串處理（O(n)）

模擬題（看迴圈層數分析）

🎉 結語
演算法不是背公式，而是學會：

「看程式 → 估時間 → 判斷能不能過」

掌握 Big-O，你就能：

準備 APCS

提升競賽能力

寫出快又漂亮的程式

※以上資料為 ChatGPT 整理
